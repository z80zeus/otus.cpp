/**
 * @file Файл содержит учебный аллокатор в соответствии с заданием.
 * @author Владимир Лазарев solock@mail.ru
 * @details Реализовать свой аллокатор памяти, который позволит выполнять операцию резервирования памяти.
 * Далее использовать этот аллокатор с контейнером std::map.
 * Аллокатор должен параметризоваться количеством выделяемых за раз элементов. Освобождение конкретного
 * элемента не предполагается - аллокатор должен освобождать всю память самостоятельно.
 * Аллокатор работает с фиксированным количеством элементов. Попытку выделить большее число элементов считать ошибкой.
 * Опционально реализовать расширяемость аллокатора. При попытке выделить число элементов, которое превышает текущее
 * зарезервированное количество, аллокатор расширяет зарезервированную память.
 * Опционально реализовать поэлементное освобождение.
 * Цель такого аллокатора – снизить количество операций выделения памяти.
 *
 * Реализация основана на выделении массива блоков при создании аллокатора.
 * Массив инициализируется как связный список:
 * |-----|-----|-----|      |-----|
 * |  T* -> T* -> T* -> ... -> 0  |
 * |-----|-----|-----|      |-----|
 * Блоки данных выделяются начиная из головы списка, и возвращаются - в голову.
 * При исчерпании блоков в списке И если аллокатор инстанцирован с параметром Extendable = true, выделяется новый массив,
 * который инициализируется в новый список аналогичным образом.
 * При освобождении блоков - они будут возвращаться в голову нового списка.
 * Разумеется, освобождение блоков приведёт к фрагментации, а поиск блока достаточной длины во фрагментированном списке
 * это операция, требующая линейное время, но - это всего лишь учебный пример ¯\_(ツ)_/¯
 * Кроме того, организация хранилища блоков в виде связного списка прямо поверх массива данных, требует, чтобы размер
 * объекта типа Т, с которым работает аллокатор - был не меньше размера указателя.
*/
#pragma once

#include <cstdlib> // std::malloc, std::free
#include <cstddef> // std::size_t
#include <utility> // std::forward
#include <cmath>   // std::ceil

#include <vector>

#include <iostream>

//#define DEBUG std::cout << "[" << this << "]: " << __PRETTY_FUNCTION__ << std::endl;
#define DEBUG

namespace z80 {

  /**
   * @brief Аллокатор, резервирующий сразу N элементов и возвращающий их по запросу.
   * @tparam T Тип элемента, с которым работает аллокатор. Должен иметь размер не меньше указателя!
   * @tparam N Количество элементов, резервируемых при создании аллокатора.
   * @tparam Extendable Расширяет (true) или не расширяет (false) аллокатор массив данных при его исчерпании.
   * В последнем случае, при попытке выделить память будет выбрасываться исключение std::bad_alloc.
   */
  template <typename T, std::size_t N = 10, bool Extendable = true>
  struct allocator {

    using value_type = T;

    template<typename U>
    struct rebind { typedef z80::allocator<U, N, Extendable> other; };

    /**
     * @brief Конструктор по-умолчанию. Инициализирует внутренние структуры данных аллокатора.
     */
    allocator() noexcept(false) {
      DEBUG
      static_assert(sizeof(T) >= sizeof(chunkT*), "z80::allocator doesn't support type less than size of pointer.");
      chunksPages = createChunkPage(N);
      chunksHead = chunksPages->head;
    };

    /**
     * @brief Копирующий конструктор ничего не копирует, а вызывает конструктор по-умолчанию.
     * Новый аллокатор будет жить своей жизнью.
     */
    allocator(const z80::allocator<T, N, Extendable>&): allocator() {
      DEBUG
    }

     /**
     * @brief Деструктор освобождает выделенную память и приводит объект в исходное состояние.
     */
    ~allocator() noexcept {
      DEBUG

      while(chunksPages) {
        if (chunksPages->head) std::free (chunksPages->head);
        auto page = chunksPages;
        chunksPages = chunksPages->next;
        std::free(page);
      }
      chunksPages = nullptr;
    };

    /**
     * @brief Выделить непрерывную область памяти для n элементов.
     * @param n Количество элементов для которых нужно выделить непрерывную область памяти.
     * @return Указатель на первый элемент.
     * @throw В случае невозможности выделения памяти - выбрасывает исключение std::bad_alloc.
     * @details Ищет в списке блоков - физически непрерывную область (блоки, лежащие в памяти один за другим) размером n
     * и возвращает указатель на первый элемент, с которого эта непрерывная область начинается.
     * Если такой непрерывной области не найдено, то дальнейшее поведение заивисит от параметра расширяемости аллосатора.
     * Если аллокатор не раширяемый - выбрасывается исключение std::bad_alloc.
     * В противном случае - создаётся новый блок элементов, который прикрепляется к существующему.
     */
    T* allocate (std::size_t n) noexcept(false) {
      DEBUG

      if (n == 0) throw std::bad_alloc ();

      auto foundChunks = getContinuousN(chunksHead, n);
      if (foundChunks.first == nullptr) {
        if (!Extendable)
          throw std::bad_alloc();
        else {
          auto n_ = std::ceil(static_cast<float>(n) / N) * N; // Размер блока округляется вверх до числа, кратного N.
          auto page = createChunkPage(n_);       // Создать новую страницу.
          page->next = chunksPages;              // Поместить новую страницу...
          chunksPages = page;                    // ... в начало списка страниц.

          foundChunks.first = page->head;        // Непрерывный массив блоков, который "нашёлся" - находится в новой странице.
          foundChunks.last = page->head + n;     // Т.к. он непрерывный - посчитать последний элемент легко.

          if (foundChunks.prev == nullptr)       // Новая страница - это единственные свободные блоки в наличии...
            chunksHead = page->head;             // ... сделать их началом списка свободных блоков.
          else                                   // Иначе:
            foundChunks.prev->next = page->head; // Прикрепить новый массив блоков к хвосту предыдущего.
        };
      }
      // Итак, или непрерывная область найдена или выделена новая - так или иначе, foundChunks инициализирован:
      if (foundChunks.first == chunksHead)               // Если найденный массив - в начале списка...
        chunksHead = foundChunks.last->next;             // ...перемотать список на первый свободный блок.
      else                                               // Иначе:
        foundChunks.prev->next = foundChunks.last->next; // "Вырезать" этот массив из списка.

      return reinterpret_cast<T*>(foundChunks.first);
    };

    /**
     * @brief Освободить область выделенную для n элементов.
     * @param p Указатель на начало области памяти.
     * @param n Количество элементов, находящихся в этой области.
     * @details Воссоздаёт в освобождаемой области памяти связный список блоков и помещает его в начало списка свободных блоков.
     */
    void deallocate (T* p, std::size_t n) noexcept(false) {
      DEBUG

      assert(n > 0);

      auto chunk = reinterpret_cast<chunkT*>(p);
      initChunks (chunk, n);
      (chunk + n - 1) -> next = chunksHead; // Т.к. область непрерывная - можно воспользоваться арифметикой указателей.
      chunksHead = chunk;                   // Освободившуюся область - в начало списка блоков.
    };

    private:

    /**
     * @brief Объединение (union) для поддержки однонаправленного списка блоков данных.
     * @details В одном и том же блоке хранится:
     * - указатель на следующий блок - если блок свободен (не выделен функцией allocate)
     * или
     * - данные типа Т - если блок занят (выделен функцией allocate).
     */
    union chunkT {
      T       data; /** Полезная нагрузка (данные). Сама по себе аллокатору не нужна. Используется только для определения размера chunkT */
      chunkT* next; /** Указатель на следующий элемент списка */
    };

    /** @brief Указатель на голову списка свободных блоков.
     * @details Ключевой элемент данных в работе аллокатора: Именно с ним работают функции allocate/deallocate.
     */
    chunkT* chunksHead  = nullptr;

    /**
     * @brief Структура, описывающая 1 страницу блоков.
     * @details Блоки запрашиваются кратно N, описание каждого такого выделения называется - страницей и хранится в
     * структуре данных chunksPage.
     * Сформированные за время работы аллокатора страницы формируют связный список. Свой, отдельный от списка
     * свободных блоков (голова которого находится в chunksHead).
     */
    struct chunksPage {
      /** @brief Указатель на головной блок этой страницы.
       * @details Инициализируется при выделении блока, удаляется - при освобождении.
       */
      chunkT* head = nullptr;

      /** @brief Указатель на следующую страницу.
       * @details Страницы образуют однонаправленный список.
       */
      chunksPage* next = nullptr;
    };

    /**
     * @brief Страницы блоков которыми оперирует аллокатор.
     * @details Список инициализируется конструктором. Расширяется - при расширении памяти. Удаляется - деструктором.
     */
    chunksPage* chunksPages = nullptr;

    /**
     * @brief Создать новую страницу блоков.
     * @param n Количество блоков в странице.
     * @return Указатель на созданную страницу.
     */
    auto
    createChunkPage(std::size_t n) const noexcept(false) {
      auto page = reinterpret_cast<chunksPage*>(std::malloc(sizeof(chunksPage)));
      if (page == nullptr) throw std::bad_alloc();
      page->next = nullptr;

      page->head = reinterpret_cast<chunkT*>(std::malloc(sizeof(chunkT) * n));
      if (page->head == nullptr) {
        std::free(page);
        throw std::bad_alloc();
      }
      initChunks(page->head, n);
      return page;
    }

    /**
     * @brief Инициализировать НЕПРЕРЫВНУЮ область памяти в качестве списка блоков.
     * @param head Голова списка.
     * @param num Количество элементов в списке.
     * @details Инициализирует область памяти, превращая её в связный однонаправленный список блоков.
     */
    void
    initChunks (chunkT* head, size_t num) const noexcept {
      while (--num != 0) {
        head->next = head + 1;
        ++head;
      };
      head->next = nullptr;
    };

    /**
     * @brief Структура, описывающая непрерывный массив блоков.
     */
    struct chunkArray {
      chunkT* prev  = nullptr; /** Указатель на блок, находящийся в списке ПЕРЕД первым блоком массива. */
      chunkT* first = nullptr; /** Указатель на первый блок в массиве. */
      chunkT* last  = nullptr; /** Указатель на последний блок в массиве */
    };

    /**
     * @brief Возвращает непрерывный массив блоков (физически следующих один за другим) в списке свободных блоков аллокатора.
     * @param head Блок, с которого начать поиск.
     * @param n Требуемая длина массива (в блоках)
     * @return Структура chunkArray описывающая непрерывный массив блоков в списке свободных блоков аллокатора:
     * prev - блок, находящийся в списке (!) свободных блоков ПЕРЕД первым блоком непрерывного массива свободных блоков.
     * first - первый блок непрерывного массива свободных блоков. nullptr - если непрерывный массив не найден.
     * last - последний блок непрерывного массива свободных блоков. nullptr - если непрерывный массив не найден.
     * @details Функция перебирает список блоков начиная с head в поисках непрерывного (в памяти) массива свободных блоков
     * размером n блоков.
     * В случае успеха - возвращает объект chunkArray с полями prev, first, last - в соответствии с расположением найденного массива.
     * Если непрерывный массив не найден - first и last будут равны nullptr. prev - последнему блоку в списке свободных
     * блоков. Если свободных блоков вообще нет - список пустой, то и prev будет равен nullptr.
     */
    auto getContinuousN (chunkT *head, std::size_t n) const {
      chunkT *first = head, *prev = nullptr;
      for (decltype(n) i = 1;
           head != nullptr;
           head = head->next, ++i)
      {
        if (i >= n) return chunkArray { prev, first, head }; // Необходимое количество блоков найдено.
        if (head->next == head + 1) continue;                // Следующий блок в памяти - свободен. Перейти к нему.
        // Сбой последовательности свободных блоков - начать заново.
        i = 0;
        prev = head;
        first = head->next;
      }
      return chunkArray { prev, nullptr, nullptr };
    }
  };

  /**
   * @brief Оператор неравенства аллокаторов z80::allocator. Эти аллокаторы всегда не равны.
   * @tparam T Тип шаблона левого аллокатора.
   * @tparam U Тип шаблона правого аллокатора.
   * @return true.
   */
  template<typename T, typename U>
  bool operator!=(const z80::allocator<T, 0, true>&, const z80::allocator<U, 0, true>&) { return true; }

  /**
   * @brief Оператор равенства аллокаторов z80::allocator. Эти аллокаторы всегда не равны.
   * @tparam T Тип шаблона левого аллокатора.
   * @tparam U Тип шаблона правого аллокатора.
   * @return false.
   */
  template<typename T, typename U>
  bool operator==(const z80::allocator<T, 0, true>&, const z80::allocator<U, 0, true>&) { return false; }
}

