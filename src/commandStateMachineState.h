/**
 * @brief Файл содержит объявление класса базового для всех классов состояний конечного автомата,
 * обрабатывающего строковые "команды" (в терминах задания).
 * @author Владимир Лазарев solock@mail.ru
 */

#pragma once

#include "commandStateMachine.h"
#include "state.h"
#include "stateMachine.h"

#include <atomic> // std::time_t
#include <ctime>  // std::time_t
#include <memory> // unique_ptr
#include <string> // std::string, std::to_string

namespace z80 {
  /**
   * @brief Класс "Состояние строкового автомата" - промежуточный класс, базовый для всех возможных состояний автомата,
   * обрабатывающего строковые "команды".
   * @details Класс является подтипом класса z80::state и наследуется от него с шаблонным параметром std::string, т.к. в
   * терминах задания команды - это строки.
   */
  class commandStateMachineState : public z80::state<std::string> {
  public:
    /**
     * @brief Вызов данного метода является сигналом о том, что автомат заканчивает работу и объекту нужно завершить
     * свой алгоритм. В данном классе этот метод не делает ничего и реализован только для того, чтобы избавить
     * классы-наследники от необходимости его реализации.
     */
    void finish() override;

    /**
     * @brief Функция записывает в объект указатель на объект-автомат, в контексте которого работает текущее состояние.
     * @param cStateMachine Указатель на автомат, в контексте которого работает данный объект-состояние.
     */
    void setCStateMachine(z80::commandStateMachine* cStateMachine);

    protected:
    /**
     * @brief Создание объектов данного класса не предусмотрено, поэтому единственный конструктор находится в защищённой
     * секции и вызывается конструкторами классов-наследников.
     * @param sm Указатель на автомат, в контексте которого работает конструируемое состояние.
     * Используется для доступа к функционалу автомата из состояния.
     */
    explicit commandStateMachineState(z80::commandStateMachine* sm);

    /**
     * @brief Функция отправки подписчикам автомата сохранённого блока команд.
     * @details В процессе работы объекта-состояния возникает необходимость отправки сформированного блока команд вовне
     * автомата. Этот функционал нужен многим классам-состояний, поэтому он вынесен в базовый класс в виде функции.
     * Эта функция вызывает метод notify у автомата, передавая ему накопленные команды, после чего - обнуляет их.
     * Строка команд предваряется служебным полем, состоящим из времени начала данного блока команд в формате unixtime
     * и постфикса - сквозного порядкового номера данного состояния:
     * <blockStartTime>.<startTimePostfix> <savedCommands>
     */
    void sendSavedCommands();

    /**
     * @brief Блок команд, накопленных объектом. Заполняется классами-наследниками.
     */
    std::string savedCommands;

    /**
     * @brief Время (unixtime) начала (открытия) текущего блока команд. Это время инициализируется текущим временем в
     * конструкторе и используется в работе функции sendSavedCommands() для идентификации блоков команд.
     * См. также startTimePostfix.
     */
    std::time_t        blockStartTime;

    /**
     * @brief Значение счётчика созданных состояний (countPostfix), присвоенное данному состоянию в конструкторе.
     * @details Это число используется для идентификации блоков команд - в дополнение к идентификации по времени начала
     * блока (см.blockStartTime). Разные значения счётчика для разных блоков команд позволяет различать блоки команд,
     * созданные в одну секунду (blockStartTime у таких блоков будут одинаковыми).
     */
    std::size_t        startTimePostfix = 0;

    /**
     * @brief Сквозной счётчик созданных состояний.
     * @details Счётчик увеличивается на 1 при конструировании каждого нового состояния. Конструктор состояния сохраняет
     * значение счётчика во внутреннюю переменную объекта startTimePostfix.
     * Т.к. счётчик - статический, его значение общее для всех объектов состояний.
     */
    static std::atomic<std::size_t> countPostfix;

    /**
     * @brief Указатель на автомат в контексте которого работает состояние.
     * @details Подобный укзаатель хранится и в z80::state<std::string>::sm, но там он указывает на базовый класс
     * автомата z80::stateMachine<std::string>, где нет доступа к дополнительным функцям класса z80::commandStateMachine.
     * Т.к. инициализация этих переменных происходит в конструкторе класса, а тот в свою очередь работает в контексте
     * конструктора самого автомата (создаваемый автомат - в конструкторе создаёт своё состояние) - на этом этапе
     * нельзя производить downcast указателя на базовый класс автомата z80::stateMachine<std::string> к указателю на
     * дочерний класс z80::commandStateMachine. Это - undefined behavior.
     * Поэтому этот класс, получая в конструкторе указатель на автомат z80::commandStateMachine, помимо передачи этого
     * указателя конструктору своего базового класса в качестве указателя на базовый класс автоматов
     * (z80::stateMachine<std::string>), сохраняет и указатель на дочерний класс автомата в поле csm.
     * Так дочерние классы состояний будут иметь постоянный доступ к функциям z80::commandStateMachine без необходимости
     * постоянного downcast'а поля z80::stateMachine<std::string>::sm.
     */
    z80::commandStateMachine* csm = nullptr;
  };
}